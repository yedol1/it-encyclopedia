# 14. 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 지역 변수의 생명 주기

- 정의 - 변수는 생성되고 할당을 통해 값을 갖고 소멸되는 생명 주기가 있다.
- 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸된다.
  ```jsx
  // 지역 변수의 생명 주기
  function foo() {
    var x = "local"; // 지역변수 x 생성 및 할당
    console.log(X); //
    return x; // 변수 x 소멸
  }

  foo(); //'local'
  console.log(x); // ReferenceError: x is not defined
  ```
- 지역 변수의 생명 주기는 함수의 생명 주기와 일치
  - 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 되고, 해당 스코프에 있는 지역 변수는 가비지 콜렉터가 해제할 때까지 함수보다 오래 생존하는 경우도 있음
    ```jsx
    var x = "global";

    function foo() {
      // 함수 내부에서 선언된 지역 변수 x는
      // 이미 호이스팅되어 undefined로 초기화되어 있음
      console.log(x); // undefined
      var x = "local";
    }

    foo();
    console.log(x); // global
    ```

### 전역 변수의 생명 주기

- 전역 코드는 함수 호출과 같이 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행
- 함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료하지만, 전역 코드에는 반환문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행문이 없을 때 종료
- `var` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되며, 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 뜻함
- 전역 객체 - 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체
  - 클라이언트 사이드 환경(브라우저)에서는 `window`, 서버 사이드 환경(Node.js)에서는 `global` 객체를 의미
  - 전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, 그리고 `var` 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 가짐

## 14.2 전역 변수의 문제점

### 암묵적 결합

- 전역 변수는 암묵적 결합을 허용한다. 이는 전역 변수를 선언한 전역, 즉 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다라는 뜻이다.
- 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 위험성은 높아진다.

### 긴 생명 주기

- 전역 변수는 생명 주기가 김
  - 메모리 리소스를 오랜 시간 소비
  - 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많음
- `var` 키워드는 변수의 중복 선언을 허용하므로 이름이 중복될 가능성이 있음

### 스코프 체인 상에서 종점에 존재

- 전역 변수는 스코프 체인 상에서 종점에 존재한다.
- 변수를 검색할 때 가장 마지막에 검색됨

### 네임스페이스 오염

- `네임스페이스`는 개체를 구분할 수 있는 범위를 나타낸다.
  - 자바스크립트는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.
  - 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수가 존재할 경우 예상치 못한 결과를 가져올 수 있다.

## 14.3 전역 변수의 사용을 억제하는 방법

- 전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야 한다. 또한 변수의 스코프는 좁을 수록 좋다.

### 즉시 실행 함수

- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨
  ```jsx
  (function() {
    var foo = ;	// 즉시 실행 함수의 지역 변수
    // ...
  }());

  console.log(foo);	// ReferenceError: foo is not defined

  ```
- 이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용됨

### 네임스페이스 객체

- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
  ```jsx
  var MYAPP = {}; // 전역 네임스페이스 객체

  MYAPP.name = "kim";

  console.log(MYAPP.name); // kim

  // 계층적 네임스페이스 구성
  var MYAPP = {};

  MYAPP.person = {
    name: "kim",
    age: 20,
  };

  console.log(MYAPP.person.name); // kim
  ```
- 식별자 충돌을 방지할 수는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하지 않음

### 모듈 패턴

- 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듦
  - 자바스크립트의 강력한 기능인 클로저를 기반으로 동작
  - 전역 변수의 억제는 물론 캡슐화까지 구현 가능
- 대부분의 객체지향 프로그래밍 언어는 `public`, `private`, `protected` 등의 접근 제한자를 사용해 공개 범위를 한정하지만, 이전 자바스크립트에는 접근 제한자를 제공하지 않음 ( 현재는 프리픽스(#) 을 통하여 접근제한자 선언 가능 )
  - 모듈 패턴은 이런 정보 은닉을 구현하기 위해 사용
    ```jsx
    var Module = (function () {
      // 은닉될 멤버
      var privateKey = 0;
      function privateMethod() {
        return ++privateKey;
      }
      // 공개될 멤버 (특권 메소드) 정의
      return {
        publickey: privateKey,
        publicMethod: function () {
          return privateMethod();
        },
      };
    })();

    console.log(Module.publicMethod()); // 1
    console.log(Module.publicMethod()); // 2 (클로저로 인한 결과)
    ```

### ES6 모듈

- ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없음
  - ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
  - 모듈 내에서 `var` 키워드로 선언한 변수는 더는 전역 변수가 아니며 `window` 객체의 프로퍼티도 아님
- `script` 태그에 `type="module"` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작

```
<script type="module" src="lib.mjs"></script>

```

- IE를 포함한 구형 브라우저에서는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적
